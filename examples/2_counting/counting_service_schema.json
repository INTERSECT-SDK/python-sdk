{
  "asyncapi": "2.6.0",
  "x-intersect-version": "0.8.4",
  "info": {
    "title": "counting-organization.counting-facility.counting-system.counting-subsystem.counting-service",
    "description": "INTERSECT schema",
    "version": "0.0.0"
  },
  "defaultContentType": "application/json",
  "capabilities": {
    "intersect_sdk": {
      "endpoints": {},
      "events": {},
      "status": {
        "$ref": "#/components/schemas/IntersectCoreStatus"
      },
      "description": "Core capability present in every INTERSECT Service.\n\nThis may be called explicitly by any Client interacting with any SDK service. Set the operation to be \"intersect_sdk.<ENDPOINT>\"."
    },
    "CountingExample": {
      "endpoints": {
        "reset_count": {
          "publish": {
            "message": {
              "schemaFormat": "application/vnd.aai.asyncapi+json;version=2.6.0",
              "contentType": "application/json",
              "traits": {
                "$ref": "#/components/messageTraits/commonHeaders"
              },
              "payload": {
                "$ref": "#/components/schemas/CountingServiceCapabilityImplementationState"
              }
            },
            "description": "Set the counter back to 0.\n\nParams\n  start_again: if True, start the counter again; if False, the\n    counter will remain off.\n\nReturns:\n  the state BEFORE the counter was reset"
          },
          "subscribe": {
            "message": {
              "schemaFormat": "application/vnd.aai.asyncapi+json;version=2.6.0",
              "contentType": "application/json",
              "traits": {
                "$ref": "#/components/messageTraits/commonHeaders"
              },
              "payload": {
                "type": "boolean",
                "title": "start_again"
              }
            },
            "description": "Set the counter back to 0.\n\nParams\n  start_again: if True, start the counter again; if False, the\n    counter will remain off.\n\nReturns:\n  the state BEFORE the counter was reset"
          }
        },
        "start_count": {
          "publish": {
            "message": {
              "schemaFormat": "application/vnd.aai.asyncapi+json;version=2.6.0",
              "contentType": "application/json",
              "traits": {
                "$ref": "#/components/messageTraits/commonHeaders"
              },
              "payload": {
                "$ref": "#/components/schemas/CountingServiceCapabilityImplementationResponse"
              }
            },
            "description": "Start the counter (potentially from any number). \"Fails\" if the counter is already running.\n\nReturns:\n  A CountingServiceCapabilityImplementationResponse object. The success value will be:\n    True - if counter was started successfully\n    False - if counter was already running and this was called"
          },
          "subscribe": {
            "message": {
              "schemaFormat": "application/vnd.aai.asyncapi+json;version=2.6.0",
              "contentType": "application/json",
              "traits": {
                "$ref": "#/components/messageTraits/commonHeaders"
              }
            },
            "description": "Start the counter (potentially from any number). \"Fails\" if the counter is already running.\n\nReturns:\n  A CountingServiceCapabilityImplementationResponse object. The success value will be:\n    True - if counter was started successfully\n    False - if counter was already running and this was called"
          }
        },
        "stop_count": {
          "publish": {
            "message": {
              "schemaFormat": "application/vnd.aai.asyncapi+json;version=2.6.0",
              "contentType": "application/json",
              "traits": {
                "$ref": "#/components/messageTraits/commonHeaders"
              },
              "payload": {
                "$ref": "#/components/schemas/CountingServiceCapabilityImplementationResponse"
              }
            },
            "description": "Stop the new ticker.\n\nReturns:\n  A CountingServiceCapabilityImplementationResponse object. The success value will be:\n    True - if counter was stopped successfully\n    False - if counter was already not running and this was called"
          },
          "subscribe": {
            "message": {
              "schemaFormat": "application/vnd.aai.asyncapi+json;version=2.6.0",
              "contentType": "application/json",
              "traits": {
                "$ref": "#/components/messageTraits/commonHeaders"
              }
            },
            "description": "Stop the new ticker.\n\nReturns:\n  A CountingServiceCapabilityImplementationResponse object. The success value will be:\n    True - if counter was stopped successfully\n    False - if counter was already not running and this was called"
          }
        }
      },
      "events": {},
      "status": {
        "$ref": "#/components/schemas/CountingServiceCapabilityImplementationState"
      },
      "description": "This example is meant to showcase that your implementation is able to track state if you want it to.\n\nPlease note that this is not an especially robust implementation, as in the instance\nthe service gets two messages at the same time, it may manage to create\ntwo threads at once."
    }
  },
  "components": {
    "schemas": {
      "IntersectCoreStatus": {
        "description": "Core status information about the INTERSECT-SDK Service as a whole.",
        "properties": {
          "uptime": {
            "format": "duration",
            "title": "Uptime",
            "type": "string"
          },
          "logical_cpus": {
            "title": "Logical CPUs",
            "type": "integer"
          },
          "physical_cpus": {
            "title": "Physical CPUs",
            "type": "integer"
          },
          "cpu_percentages": {
            "items": {
              "type": "number"
            },
            "title": "CPU Percentages",
            "type": "array"
          },
          "service_cpu_percentage": {
            "title": "Service CPU Usage Percentage",
            "type": "number"
          },
          "memory_total": {
            "title": "Memory Total",
            "type": "integer"
          },
          "memory_usage_percentage": {
            "title": "Memory Usage Percentage",
            "type": "number"
          },
          "service_memory_percentage": {
            "title": "Service Memory Usage Percentage",
            "type": "number"
          },
          "disk_total": {
            "title": "Disk Total",
            "type": "integer"
          },
          "disk_usage_percentage": {
            "title": "Disk Usage Percentage",
            "type": "number"
          }
        },
        "required": [
          "uptime",
          "logical_cpus",
          "physical_cpus",
          "cpu_percentages",
          "service_cpu_percentage",
          "memory_total",
          "memory_usage_percentage",
          "service_memory_percentage",
          "disk_total",
          "disk_usage_percentage"
        ],
        "title": "IntersectCoreStatus",
        "type": "object"
      },
      "CountingServiceCapabilityImplementationState": {
        "description": "We can't just use any class to represent state. This class either needs to extend Pydantic's BaseModel class, or be a dataclass. Both the Python standard library's dataclass and Pydantic's dataclass are valid.",
        "properties": {
          "count": {
            "default": 0,
            "minimum": 0,
            "title": "Count",
            "type": "integer"
          },
          "counting": {
            "default": false,
            "title": "Counting",
            "type": "boolean"
          }
        },
        "title": "CountingServiceCapabilityImplementationState",
        "type": "object"
      },
      "__CountingServiceCapabilityImplementationState": {
        "description": "We can't just use any class to represent state. This class either needs to extend Pydantic's BaseModel class, or be a dataclass. Both the Python standard library's dataclass and Pydantic's dataclass are valid.",
        "properties": {
          "count": {
            "default": 0,
            "minimum": 0,
            "title": "Count",
            "type": "integer"
          },
          "counting": {
            "default": false,
            "title": "Counting",
            "type": "boolean"
          }
        },
        "title": "CountingServiceCapabilityImplementationState",
        "type": "object"
      },
      "CountingServiceCapabilityImplementationResponse": {
        "properties": {
          "state": {
            "$ref": "#/components/schemas/__CountingServiceCapabilityImplementationState"
          },
          "success": {
            "title": "Success",
            "type": "boolean"
          }
        },
        "required": [
          "state",
          "success"
        ],
        "title": "CountingServiceCapabilityImplementationResponse",
        "type": "object"
      }
    },
    "messageTraits": {
      "commonHeaders": {
        "userspaceHeaders": {
          "description": "ALL request/response/command messages must contain this header.\n\nWe do not include the content type of the message in the header, it is handled separately.",
          "properties": {
            "message_id": {
              "description": "Unique message ID",
              "title": "Message Id",
              "type": "string"
            },
            "campaign_id": {
              "description": "ID associated with a campaign",
              "title": "Campaign Id",
              "type": "string"
            },
            "request_id": {
              "description": "ID associated with a specific request message and response message sequence",
              "title": "Request Id",
              "type": "string"
            },
            "source": {
              "description": "source of the message",
              "pattern": "^[a-z0-9][-a-z0-9.]*[-a-z0-9]$",
              "title": "Source",
              "type": "string"
            },
            "destination": {
              "description": "destination of the message",
              "pattern": "^[a-z0-9][-a-z0-9.]*[-a-z0-9]$",
              "title": "Destination",
              "type": "string"
            },
            "created_at": {
              "description": "the UTC timestamp of message creation",
              "title": "Created At",
              "type": "string"
            },
            "sdk_version": {
              "description": "SemVer string of SDK's version, used to check for compatibility",
              "pattern": "^\\d+\\.\\d+\\.\\d+$",
              "title": "Sdk Version",
              "type": "string"
            },
            "operation_id": {
              "description": "Name of capability and operation we want to call, in the format ${CAPABILITY_NAME}.${FUNCTION_NAME}",
              "title": "Operation Id",
              "type": "string"
            },
            "data_handler": {
              "description": "Code signifying where data is stored.",
              "type": "string"
            },
            "has_error": {
              "description": "If this value is True, the payload will contain the error message (a string)",
              "title": "Has Error",
              "type": "string"
            }
          },
          "required": [
            "message_id",
            "campaign_id",
            "request_id",
            "source",
            "destination",
            "created_at",
            "sdk_version",
            "operation_id"
          ],
          "title": "UserspaceMessageHeaders",
          "type": "object"
        },
        "eventHeaders": {
          "description": "ALL event messages must include this header.\n\nWe do not include the content type of the message in the header, it is handled separately.",
          "properties": {
            "message_id": {
              "description": "Unique message ID",
              "title": "Message Id",
              "type": "string"
            },
            "source": {
              "description": "source of the message",
              "pattern": "^[a-z0-9][-a-z0-9.]*[-a-z0-9]$",
              "title": "Source",
              "type": "string"
            },
            "created_at": {
              "description": "the UTC timestamp of message creation",
              "title": "Created At",
              "type": "string"
            },
            "sdk_version": {
              "description": "SemVer string of SDK's version, used to check for compatibility",
              "pattern": "^\\d+\\.\\d+\\.\\d+$",
              "title": "Sdk Version",
              "type": "string"
            },
            "data_handler": {
              "description": "Code signifying where data is stored.",
              "type": "string"
            },
            "capability_name": {
              "description": "The name of the capability which emitted the event originally.",
              "pattern": "^[a-zA-Z0-9]\\w*$",
              "title": "Capability Name",
              "type": "string"
            },
            "event_name": {
              "description": "The name of the event that was emitted, namespaced to the capability.",
              "pattern": "^[a-zA-Z0-9]\\w*$",
              "title": "Event Name",
              "type": "string"
            }
          },
          "required": [
            "message_id",
            "source",
            "created_at",
            "sdk_version",
            "capability_name",
            "event_name"
          ],
          "title": "EventMessageHeaders",
          "type": "object"
        }
      }
    }
  }
}
